/**
 * Student Attendance Tracker - Production Ready
 * Version: 1.0.0
 * Author: Sushil RK
 * Features: Error handling, validation, offline support, toast notifications
 */

(function() {
    'use strict';
    
    // Configuration
    const CONFIG = {
        MAX_SUBJECTS: 7,
        THRESHOLD: 75,
        STORAGE_KEY: 'attendanceSubjects_v1',
        VERSION: '1.0.0'
    };
    
    // Error tracking
    const ErrorTracker = {
        errors: [],
        log: function(error, context) {
            const errorInfo = {
                timestamp: new Date().toISOString(),
                message: error.message || error,
                stack: error.stack,
                context: context,
                userAgent: navigator.userAgent
            };
            this.errors.push(errorInfo);
            console.error('ðŸ› Error tracked:', errorInfo);
            
            // Store last 50 errors
            if (this.errors.length > 50) {
                this.errors.shift();
            }
            localStorage.setItem('attendanceErrors', JSON.stringify(this.errors));
        },
        getErrors: function() {
            return this.errors;
        },
        clear: function() {
            this.errors = [];
            localStorage.removeItem('attendanceErrors');
        }
    };
    
    // State management
    let subjects = [];
    let isInitialized = false;
    
    // DOM Elements cache
    const DOM = {};
    
    // Toast Notification System
    const Toast = {
        container: null,
        
        init: function() {
            this.container = document.getElementById('toastContainer');
            if (!this.container) {
                this.container = document.createElement('div');
                this.container.id = 'toastContainer';
                this.container.className = 'toast-container';
                this.container.setAttribute('role', 'region');
                this.container.setAttribute('aria-live', 'polite');
                this.container.setAttribute('aria-atomic', 'true');
                document.body.appendChild(this.container);
            }
        },
        
        show: function(message, type = 'info', duration = 3000) {
            if (!this.container) this.init();
            
            const toast = document.createElement('div');
            toast.className = `toast toast-${type}`;
            toast.setAttribute('role', 'alert');
            
            const icons = {
                success: 'âœ“',
                error: 'âœ—',
                warning: 'âš ',
                info: 'â„¹'
            };
            
            toast.innerHTML = `
                <span class="toast-icon">${icons[type]}</span>
                <span class="toast-message">${message}</span>
                <button class="toast-close" aria-label="Close notification">&times;</button>
            `;
            
            this.container.appendChild(toast);
            
            // Animate in
            requestAnimationFrame(() => {
                toast.classList.add('show');
            });
            
            // Close button
            toast.querySelector('.toast-close').addEventListener('click', () => {
                this.hide(toast);
            });
            
            // Auto dismiss
            if (duration > 0) {
                setTimeout(() => this.hide(toast), duration);
            }
            
            return toast;
        },
        
        hide: function(toast) {
            toast.classList.remove('show');
            toast.classList.add('hide');
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.parentNode.removeChild(toast);
                }
            }, 300);
        },
        
        success: function(message) {
            return this.show(message, 'success');
        },
        
        error: function(message) {
            return this.show(message, 'error', 5000);
        },
        
        warning: function(message) {
            return this.show(message, 'warning', 4000);
        },
        
        info: function(message) {
            return this.show(message, 'info');
        }
    };
    
    // Validation utilities
    const Validator = {
        subjectName: function(name) {
            if (!name || typeof name !== 'string') {
                return { valid: false, error: 'Subject name is required' };
            }
            
            const trimmed = name.trim();
            
            if (trimmed.length === 0) {
                return { valid: false, error: 'Subject name cannot be empty' };
            }
            
            if (trimmed.length > 25) {
                return { valid: false, error: 'Subject name must be 25 characters or less' };
            }
            
            // Check for duplicate names
            const exists = subjects.some(s => 
                s.name.toLowerCase() === trimmed.toLowerCase()
            );
            if (exists) {
                return { valid: false, error: 'Subject already exists' };
            }
            
            // Check for invalid characters
            if (!/^[a-zA-Z0-9\s\-\_]+$/.test(trimmed)) {
                return { valid: false, error: 'Subject name contains invalid characters' };
            }
            
            return { valid: true, value: trimmed };
        }
    };
    
    // Storage management with error handling
    const Storage = {
        save: function() {
            try {
                const data = JSON.stringify(subjects);
                localStorage.setItem(CONFIG.STORAGE_KEY, data);
                
                // Also save timestamp
                localStorage.setItem(`${CONFIG.STORAGE_KEY}_timestamp`, Date.now().toString());
                return true;
            } catch (error) {
                ErrorTracker.log(error, 'Storage.save');
                
                // Check if quota exceeded
                if (error.name === 'QuotaExceededError') {
                    Toast.error('Storage limit reached. Please delete some subjects.');
                } else {
                    Toast.error('Failed to save data. Please try again.');
                }
                return false;
            }
        },
        
        load: function() {
            try {
                const data = localStorage.getItem(CONFIG.STORAGE_KEY);
                if (!data) return [];
                
                const parsed = JSON.parse(data);
                
                // Validate data structure
                if (!Array.isArray(parsed)) {
                    throw new Error('Invalid data structure');
                }
                
                return parsed.filter(item => 
                    item && 
                    typeof item === 'object' &&
                    typeof item.name === 'string' &&
                    typeof item.attended === 'number' &&
                    typeof item.total === 'number'
                );
            } catch (error) {
                ErrorTracker.log(error, 'Storage.load');
                Toast.error('Failed to load saved data. Starting fresh.');
                return [];
            }
        },
        
        export: function() {
            try {
                const data = {
                    version: CONFIG.VERSION,
                    timestamp: new Date().toISOString(),
                    subjects: subjects
                };
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `attendance-backup-${new Date().toISOString().split('T')[0]}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                Toast.success('Backup downloaded successfully!');
                return true;
            } catch (error) {
                ErrorTracker.log(error, 'Storage.export');
                Toast.error('Failed to export data');
                return false;
            }
        },
        
        import: function(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        const data = JSON.parse(e.target.result);
                        
                        if (!data.subjects || !Array.isArray(data.subjects)) {
                            throw new Error('Invalid backup file format');
                        }
                        
                        // Validate subjects
                        const validSubjects = data.subjects.filter(item =>
                            item &&
                            typeof item.name === 'string' &&
                            typeof item.attended === 'number' &&
                            typeof item.total === 'number'
                        );
                        
                        if (validSubjects.length > CONFIG.MAX_SUBJECTS) {
                            throw new Error(`Backup contains more than ${CONFIG.MAX_SUBJECTS} subjects`);
                        }
                        
                        subjects = validSubjects;
                        Storage.save();
                        renderSubjects();
                        updateStats();
                        Toast.success(`Imported ${validSubjects.length} subjects successfully!`);
                        resolve(true);
                    } catch (error) {
                        ErrorTracker.log(error, 'Storage.import');
                        Toast.error('Failed to import: ' + error.message);
                        reject(error);
                    }
                };
                reader.onerror = () => {
                    Toast.error('Failed to read file');
                    reject(new Error('File read error'));
                };
                reader.readAsText(file);
            });
        }
    };
    
    // Calculate percentage
    function calculatePercentage(attended, total) {
        if (total === 0 || attended < 0 || total < 0) return 0;
        return Math.min(100, Math.round((attended / total) * 100));
    }
    
    // Calculate classes needed to reach 75%
    function classesNeeded(attended, total) {
        if (total === 0) return 1;
        const currentPercentage = (attended / total) * 100;
        if (currentPercentage >= CONFIG.THRESHOLD) return 0;
        
        const needed = Math.ceil((0.75 * total - attended) / 0.25);
        return Math.max(0, needed);
    }
    
    // Cache DOM elements
    function cacheDOM() {
        DOM.subjectList = document.getElementById('subjectList');
        DOM.addSubjectBtn = document.getElementById('addSubjectBtn');
        DOM.modal = document.getElementById('modal');
        DOM.subjectName = document.getElementById('subjectName');
        DOM.saveBtn = document.getElementById('saveBtn');
        DOM.cancelBtn = document.getElementById('cancelBtn');
        DOM.modalClose = document.getElementById('modalClose');
        DOM.avgAttendance = document.getElementById('avgAttendance');
        DOM.subjectCount = document.getElementById('subjectCount');
        DOM.loadingScreen = document.getElementById('loadingScreen');
        
        // Validate critical elements
        const required = ['subjectList', 'addSubjectBtn', 'modal', 'subjectName'];
        const missing = required.filter(id => !DOM[id]);
        if (missing.length > 0) {
            throw new Error(`Missing required DOM elements: ${missing.join(', ')}`);
        }
    }
    
    // Render subjects
    function renderSubjects() {
        if (!DOM.subjectList) return;
        
        DOM.subjectList.innerHTML = '';
        
        if (subjects.length === 0) {
            DOM.subjectList.innerHTML = `
                <div class="empty-state">
                    <div class="empty-state-icon">ðŸ“š</div>
                    <h3>No subjects yet</h3>
                    <p>Add up to ${CONFIG.MAX_SUBJECTS} subjects to track your attendance and stay eligible for exams!</p>
                </div>
            `;
            if (DOM.addSubjectBtn) {
                DOM.addSubjectBtn.disabled = false;
            }
            return;
        }
        
        const fragment = document.createDocumentFragment();
        
        subjects.forEach((subject, index) => {
            const percentage = calculatePercentage(subject.attended, subject.total);
            const isEligible = percentage >= CONFIG.THRESHOLD;
            const needed = classesNeeded(subject.attended, subject.total);
            
            const card = document.createElement('div');
            card.className = 'subject-card';
            card.setAttribute('role', 'listitem');
            card.setAttribute('aria-label', `${subject.name}: ${percentage}% attendance`);
            
            card.innerHTML = `
                <div class="subject-header">
                    <span class="subject-name">${escapeHtml(subject.name)}</span>
                    <button class="delete-btn" data-index="${index}" aria-label="Delete ${escapeHtml(subject.name)}">Delete</button>
                </div>
                
                <div class="progress-container">
                    <div class="progress-bar-bg">
                        <div class="progress-bar-fill ${isEligible ? 'eligible' : 'not-eligible'}" 
                             style="width: ${Math.min(percentage, 100)}%"
                             aria-valuenow="${percentage}" 
                             aria-valuemin="0" 
                             aria-valuemax="100"
                             role="progressbar">
                            ${percentage}%
                        </div>
                        <div class="progress-marker"></div>
                    </div>
                </div>
                
                <div class="subject-info">
                    <span class="attendance-text">Attended: ${subject.attended}/${subject.total} classes</span>
                    <span class="status ${isEligible ? 'eligible' : 'not-eligible'}">
                        ${isEligible ? 'âœ“ ELIGIBLE' : `âš  Need ${needed} more`}
                    </span>
                </div>
                
                <div class="buttons">
                    <button class="btn-present" data-index="${index}" data-action="present" aria-label="Mark present for ${escapeHtml(subject.name)}">
                        <span aria-hidden="true">âœ“</span> Present
                    </button>
                    <button class="btn-absent" data-index="${index}" data-action="absent" aria-label="Mark absent for ${escapeHtml(subject.name)}">
                        <span aria-hidden="true">âœ—</span> Absent
                    </button>
                </div>
            `;
            
            fragment.appendChild(card);
        });
        
        DOM.subjectList.appendChild(fragment);
        
        // Add event listeners using event delegation
        DOM.subjectList.addEventListener('click', handleSubjectClick);
        
        // Update add button state
        if (DOM.addSubjectBtn) {
            DOM.addSubjectBtn.disabled = subjects.length >= CONFIG.MAX_SUBJECTS;
            DOM.addSubjectBtn.textContent = subjects.length >= CONFIG.MAX_SUBJECTS 
                ? 'Max 7 Subjects' 
                : '+ Add Subject';
        }
    }
    
    // Handle clicks on subject cards
    function handleSubjectClick(e) {
        const target = e.target;
        
        // Handle delete button
        if (target.classList.contains('delete-btn')) {
            const index = parseInt(target.dataset.index);
            deleteSubject(index);
            return;
        }
        
        // Handle present/absent buttons
        if (target.classList.contains('btn-present') || target.classList.contains('btn-absent')) {
            const index = parseInt(target.dataset.index);
            const isPresent = target.classList.contains('btn-present');
            markAttendance(index, isPresent);
        }
    }
    
    // Escape HTML to prevent XSS
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Update statistics
    function updateStats() {
        if (!DOM.subjectCount || !DOM.avgAttendance) return;
        
        DOM.subjectCount.textContent = `${subjects.length}/${CONFIG.MAX_SUBJECTS}`;
        
        if (subjects.length === 0) {
            DOM.avgAttendance.textContent = '0%';
            return;
        }
        
        let totalPercentage = 0;
        subjects.forEach(subject => {
            totalPercentage += calculatePercentage(subject.attended, subject.total);
        });
        
        const avg = Math.round(totalPercentage / subjects.length);
        DOM.avgAttendance.textContent = `${avg}%`;
    }
    
    // Mark attendance
    function markAttendance(index, isPresent) {
        try {
            if (index < 0 || index >= subjects.length) {
                throw new Error('Invalid subject index');
            }
            
            subjects[index].total++;
            if (isPresent) {
                subjects[index].attended++;
            }
            
            if (Storage.save()) {
                renderSubjects();
                updateStats();
                
                const subject = subjects[index];
                const percentage = calculatePercentage(subject.attended, subject.total);
                
                if (isPresent && percentage >= CONFIG.THRESHOLD) {
                    Toast.success(`${escapeHtml(subject.name)} is now eligible! ðŸŽ‰`);
                }
            }
        } catch (error) {
            ErrorTracker.log(error, 'markAttendance');
            Toast.error('Failed to update attendance');
        }
    }
    
    // Delete subject
    function deleteSubject(index) {
        try {
            if (index < 0 || index >= subjects.length) {
                throw new Error('Invalid subject index');
            }
            
            const subjectName = subjects[index].name;
            
            if (confirm(`Are you sure you want to delete "${subjectName}"?`)) {
                subjects.splice(index, 1);
                
                if (Storage.save()) {
                    renderSubjects();
                    updateStats();
                    Toast.success(`"${escapeHtml(subjectName)}" deleted successfully`);
                }
            }
        } catch (error) {
            ErrorTracker.log(error, 'deleteSubject');
            Toast.error('Failed to delete subject');
        }
    }
    
    // Add new subject
    function addSubject() {
        try {
            const input = DOM.subjectName;
            const name = input.value;
            
            const validation = Validator.subjectName(name);
            
            if (!validation.valid) {
                Toast.error(validation.error);
                input.classList.add('error');
                setTimeout(() => input.classList.remove('error'), 3000);
                return;
            }
            
            if (subjects.length >= CONFIG.MAX_SUBJECTS) {
                Toast.error(`Maximum ${CONFIG.MAX_SUBJECTS} subjects allowed`);
                return;
            }
            
            subjects.push({
                name: validation.value,
                attended: 0,
                total: 0,
                createdAt: Date.now()
            });
            
            if (Storage.save()) {
                input.value = '';
                closeModal();
                renderSubjects();
                updateStats();
                Toast.success(`"${escapeHtml(validation.value)}" added successfully!`);
            }
        } catch (error) {
            ErrorTracker.log(error, 'addSubject');
            Toast.error('Failed to add subject');
        }
    }
    
    // Modal functions
    function openModal() {
        if (DOM.modal) {
            DOM.modal.classList.remove('hidden');
            DOM.modal.setAttribute('aria-hidden', 'false');
            if (DOM.subjectName) {
                DOM.subjectName.focus();
            }
            document.body.style.overflow = 'hidden';
        }
    }
    
    function closeModal() {
        if (DOM.modal) {
            DOM.modal.classList.add('hidden');
            DOM.modal.setAttribute('aria-hidden', 'true');
            if (DOM.subjectName) {
                DOM.subjectName.value = '';
                DOM.subjectName.classList.remove('error');
            }
            document.body.style.overflow = '';
        }
    }
    
    // Handle keyboard shortcuts
    function handleKeyboard(e) {
        // ESC to close modal
        if (e.key === 'Escape' && DOM.modal && !DOM.modal.classList.contains('hidden')) {
            closeModal();
        }
        
        // CTRL/CMD + N to add new subject
        if ((e.ctrlKey || e.metaKey) && e.key === 'n') {
            e.preventDefault();
            if (subjects.length < CONFIG.MAX_SUBJECTS) {
                openModal();
            }
        }
    }
    
    // Initialize application
    function init() {
        try {
            // Remove loading screen
            setTimeout(() => {
                if (DOM.loadingScreen) {
                    DOM.loadingScreen.classList.add('hidden');
                    setTimeout(() => {
                        if (DOM.loadingScreen.parentNode) {
                            DOM.loadingScreen.parentNode.removeChild(DOM.loadingScreen);
                        }
                    }, 500);
                }
            }, 500);
            
            // Load saved data
            subjects = Storage.load();
            
            // Initial render
            renderSubjects();
            updateStats();
            
            // Initialize toast system
            Toast.init();
            
            isInitialized = true;
            console.log('âœ… Attendance Tracker initialized successfully');
            
        } catch (error) {
            ErrorTracker.log(error, 'init');
            console.error('âŒ Failed to initialize app:', error);
            Toast.error('Failed to initialize app. Please refresh the page.');
        }
    }
    
    // Event listeners setup
    function setupEventListeners() {
        // Add subject button
        if (DOM.addSubjectBtn) {
            DOM.addSubjectBtn.addEventListener('click', () => {
                if (subjects.length < CONFIG.MAX_SUBJECTS) {
                    openModal();
                } else {
                    Toast.warning(`Maximum ${CONFIG.MAX_SUBJECTS} subjects allowed`);
                }
            });
        }
        
        // Save button
        if (DOM.saveBtn) {
            DOM.saveBtn.addEventListener('click', addSubject);
        }
        
        // Cancel button
        if (DOM.cancelBtn) {
            DOM.cancelBtn.addEventListener('click', closeModal);
        }
        
        // Modal close button
        if (DOM.modalClose) {
            DOM.modalClose.addEventListener('click', closeModal);
        }
        
        // Input enter key
        if (DOM.subjectName) {
            DOM.subjectName.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    addSubject();
                }
            });
        }
        
        // Modal backdrop click
        if (DOM.modal) {
            DOM.modal.addEventListener('click', (e) => {
                if (e.target === DOM.modal) {
                    closeModal();
                }
            });
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', handleKeyboard);
        
        // Handle visibility change (save data when tab is hidden)
        document.addEventListener('visibilitychange', () => {
            if (document.hidden && isInitialized) {
                Storage.save();
            }
        });
        
        // Handle before unload
        window.addEventListener('beforeunload', () => {
            if (isInitialized) {
                Storage.save();
            }
        });
        
        // Handle online/offline
        window.addEventListener('online', () => {
            Toast.success('You are back online!');
        });
        
        window.addEventListener('offline', () => {
            Toast.warning('You are offline. Data will be saved locally.');
        });
    }
    
    // Wait for DOM to be ready
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            try {
                cacheDOM();
                setupEventListeners();
                init();
            } catch (error) {
                ErrorTracker.log(error, 'DOMContentLoaded');
                console.error('âŒ Failed to start app:', error);
            }
        });
    } else {
        // DOM already loaded
        try {
            cacheDOM();
            setupEventListeners();
            init();
        } catch (error) {
            ErrorTracker.log(error, 'immediate');
            console.error('âŒ Failed to start app:', error);
        }
    }
    
    // Expose limited API for debugging
    window.AttendanceTracker = {
        version: CONFIG.VERSION,
        getSubjects: () => [...subjects],
        getStats: () => ({
            total: subjects.length,
            max: CONFIG.MAX_SUBJECTS,
            average: subjects.length > 0 
                ? Math.round(subjects.reduce((sum, s) => sum + calculatePercentage(s.attended, s.total), 0) / subjects.length)
                : 0
        }),
        exportData: Storage.export,
        importData: Storage.import,
        getErrors: ErrorTracker.getErrors,
        clearErrors: ErrorTracker.clear
    };
    
})();